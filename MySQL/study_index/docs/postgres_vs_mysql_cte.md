# PostgreSQL vs MySQL CTE 비교

## 0. 요약

- **주제**  
  PostgreSQL과 MySQL에서 CTE(Common Table Expression)의 동작 차이 비교

- **핵심 포인트**
  - PostgreSQL: CTE를 materialized view에 가깝게 다루는 경향
  - MySQL: CTE를 인라인 최적화·재계산 가능한 쿼리 블록으로 취급
  - 동일한 CTE 패턴이라도 두 DB에서 동작·성능·제약이 크게 다를 수 있음

---

## 1. 개념 비교

| 항목                        | PostgreSQL                            | MySQL 8.x                                |
| --------------------------- | ------------------------------------- | ---------------------------------------- |
| CTE 문법                    | `WITH [RECURSIVE] name AS (subquery)` | 동일                                     |
| 기본 동작                   | materialized 경향 (중간 결과 캐시)    | 인라인/재계산 가능, 반드시 materialize X |
| 재귀 CTE 지원               | 지원                                  | 지원                                     |
| INSERT/UPDATE/DELETE와 조합 | 비교적 안정                           | 제약·함정 존재                           |

---

## 2. 동작 방식

### 2-1. PostgreSQL

- CTE를 하나의 "중간 결과"로 보는 경향
- 동일 CTE 여러 번 참조 → 캐시된 결과 재사용
- 복잡한 쿼리 구조에서 **예측 가능한 의미·동작** 제공

### 2-2. MySQL

- CTE를 반드시 별도 결과로 물리화하지 않음
- 옵티마이저가 CTE를 서브쿼리처럼 인라인하거나 재계산 가능
- CTE 재사용이 항상 "한 번 계산 후 재활용"이 아님

---

## 3. 재귀 CTE

| 항목             | PostgreSQL                    | MySQL 8.x                             |
| ---------------- | ----------------------------- | ------------------------------------- |
| 재귀 깊이 제한   | 설정 가능, 기본값 충분히 높음 | `cte_max_recursion_depth` (기본 1000) |
| 대량 데이터 생성 | 가능하나 성능/설계 주의 필요  | 깊이·성능·제약으로 실무에서 비권장    |
| 에러 패턴        | 설계 오류 위주                | 깊이 초과·Can't reopen table 가능     |

- PostgreSQL: 복잡한 계층 구조 탐색/대량 재귀 쿼리에 상대적으로 유리
- MySQL: 재귀 깊이·CTE 제약 고려 필요, 대량 데이터 생성에는 부적합

---

## 4. INSERT/UPDATE/DELETE + CTE 비교

### 4-1. PostgreSQL

- 패턴 예
  - `WITH cte AS (...) UPDATE ... FROM cte ...`
  - `WITH cte AS (...) INSERT INTO ... SELECT ... FROM cte;`
- 의미·동작이 직관적, 예측 가능
  - CTE를 실제 물리 테이블처럼 한 번 계산 후 재사용하는 느낌

### 4-2. MySQL

- 동일 패턴 사용 시
  - CTE 인라인/재계산 전략에 따라 예상과 다른 실행 계획 가능
  - `Can't reopen table` 류 에러 발생 위험
- 실무 권장 사항
  - **조회용 CTE**와 **변경 쿼리**는 분리하는 방향 선호
  - 변경 쿼리에는 TEMP TABLE 또는 영구 테이블 기반 설계 우선

---

## 5. 성능 측면 비교

| 관점            | PostgreSQL                           | MySQL 8.x                            |
| --------------- | ------------------------------------ | ------------------------------------ |
| 단순 조회       | CTE 사용 시 가독성 + 적절한 성능     | CTE 인라인 최적화로 성능 괜찮은 편   |
| 복잡 파이프라인 | CTE 체이닝으로 구조적 쿼리 설계 가능 | CTE 사용 과도 시 예상 밖 최적화 가능 |
| 대량 재귀       | 설계에 따라 활용 가능                | 재귀 깊이 및 엔진 제약으로 부적합    |
| 대량 더미 생성  | 가능하나 보통 다른 메커니즘 선호     | TEMP TABLE/헬퍼 테이블 방식 추천     |

---

## 6. 실무 사용 가이드

### 6-1. PostgreSQL에서 CTE

- 적극 활용 대상
  - 복잡한 보고/집계 쿼리
  - 여러 단계의 변환·필터링 파이프라인
  - 계층 구조 탐색(재귀 CTE)
- 주의점
  - 깊은 CTE 체인 + 큰 데이터셋 → 성능 확인 필요

### 6-2. MySQL에서 CTE

- 제한적 활용 권장
  - 가독성 향상을 위한 단순 조회용 CTE
  - INSERT/UPDATE/DELETE와 완전히 분리된 SELECT 쿼리
- 비권장 패턴
  - 재귀 CTE 기반 대량 데이터 생성
  - CTE + INSERT/UPDATE/DELETE 복합 파이프라인
  - CTE에 다중 접근하는 복잡 조인 구조

---

## 7. 요약 정리

- PostgreSQL

  - CTE를 구조화·가독성 향상 도구로 적극 사용 가능
  - 복잡 쿼리 설계에 강점

- MySQL
  - CTE는 "가독성 향상용 부가 기능" 정도로 제한적 사용 권장
  - 대량 데이터 생성/변경에는 TEMP TABLE, 헬퍼 테이블, 전통적인 INSERT ... SELECT 패턴이 더 안전
