# 대규모 테스트 데이터 생성 Best Practice (MySQL 중심)

## 0. 요약

- **목표**  
  인덱스·쿼리 성능 실험용으로 수십만~수백만 건 데이터 생성 시 안정적·재현 가능한 방법 정리

- **핵심 원칙**
  - 데이터 생성 로직 최대한 단순화
  - DB 엔진 제약(CTE, 재귀, 트랜잭션 비용) 고려
  - 반복 실행·리셋 가능 구조 설계

---

## 1. 기본 전략

### 1-1. 스키마/데이터 분리

- 스키마 정의와 데이터 생성 로직 분리
  - 예: `schema.sql`, `bulk_data.sql` 별도 파일
- 장점
  - 테이블 구조 변경과 데이터 생성 전략을 독립적으로 조정 가능

### 1-2. SQL vs 애플리케이션 코드 역할 분리

- SQL 스크립트
  - 테이블 생성/삭제, 인덱스 정의, 대량 삽입 핵심 로직
- 애플리케이션 코드(Java 등)
  - 소량 샘플 데이터, 시나리오/플로우 테스트용 데이터

---

## 2. MySQL에서 권장하는 데이터 생성 패턴

### 2-1. 숫자/시퀀스 헬퍼 테이블 활용

- TEMP TABLE 또는 영구 테이블에 0~N 숫자 저장
- 예시

  - `seq_10`: 0~9
  - `seq_1k`: 0~999
  - 조인/곱셈으로 0~100k, 0~1M 등 확장

- 장점
  - CTE/재귀 없이 대량 숫자 빠르게 생성
  - 여러 스크립트에서 재사용 가능 (영구 테이블인 경우)

### 2-2. INSERT ... SELECT 패턴

- 직접 루프 돌리지 않고, 한 번의 INSERT로 많은 행 생성
- 예시
  - `INSERT INTO customers (...) SELECT ... FROM seq_100k;`
  - `INSERT INTO orders (...) SELECT ... FROM customers JOIN seq_10 ...;`

### 2-3. 랜덤 데이터 생성

- `RAND()`, 모듈 연산, CASE 문 활용
  - 날짜 분포: `DATE_SUB(NOW(), INTERVAL (id % 365) DAY)`
  - 상태 값: `CASE (FLOOR(RAND() * 4)) ... END`
  - 금액: `10000 + FLOOR(RAND() * 1000000)`

---

## 3. 피해야 할 패턴

### 3-1. 재귀 CTE 기반 대량 데이터 생성

- 문제
  - 재귀 깊이 제한 (`cte_max_recursion_depth`)
  - `Can't reopen table` 류 엔진 제약
  - 성능·디버깅 측면에서 불리

### 3-2. 애플리케이션 단일 row 반복 INSERT

- 문제

  - 네트워크 왕복, 트랜잭션 오버헤드로 인한 심각한 속도 저하
  - 수십만 건 이상에서 비현실적

- 예외
  - 의도적 지연/트랜잭션 특성을 시험하는 벤치마크 용도

### 3-3. 인덱스가 많은 상태에서 초기 대량 INSERT

- 문제
  - 인덱스가 많을수록 INSERT 비용 증가
- 전략
  - 가능하다면 데이터 생성 후 인덱스 생성
  - 또는 최소한의 인덱스만 유지하고 나머지는 테스트 시점에 추가/삭제

---

## 4. 실행·리셋 전략

### 4-1. 전체 초기화 스크립트

- 구성 요소
  - 기존 데이터 및 테이블 DROP
  - 스키마 재생성
  - 헬퍼 테이블 생성
  - 대량 데이터 INSERT
- 실행 예시
  - `mysql ... < sql/schema_and_bulk_data.sql`

### 4-2. Docker + 볼륨 전략

- DB 컨테이너 + named volume 조합 시
  - 컨테이너 삭제만으로는 데이터 삭제 안 됨
  - 볼륨 삭제 필요 (`docker volume rm ...`)
- 개발용 팁
  - "볼륨 유지 + SQL로 리셋" 방식을 기본 전략으로 두고
  - 볼륨 삭제는 환경 전체 초기화가 필요할 때만 사용

---

## 5. 인덱스 실험을 위한 데이터 설계 팁

### 5-1. 분포 설계

- 균등 분포 vs 편향 분포
  - 인덱스 효과를 보고 싶다면 특정 값에 편향된 분포도 고려
  - 예: 도시 대부분이 `Seoul`, 나머지 소수 도시

### 5-2. 시간 축 데이터

- 최근 1년, 3년 등 기간 설정 후 랜덤 분포
  - `DATE_SUB(NOW(), INTERVAL (RAND() * 365) DAY)` 등
- 인덱스 효과 확인 포인트
  - 범위 조건 (`BETWEEN`, `>=`/`<`)에서 인덱스 활용 여부

### 5-3. 조인 키 설계

- FK 기반 조인 키에 적절한 인덱스 부여
  - `orders.customer_id` + `orders.order_date` 복합 인덱스 등
- 실험
  - 인덱스 제거/생성 전후 실행 계획(EXPLAIN) 비교

---

## 6. 스크립트 작성 시 체크리스트

- [ ] 스키마 정의와 대량 데이터 생성 스크립트 분리
- [ ] DROP/CREATE 순서 명확히 정의
- [ ] 헬퍼 숫자 테이블 생성 구문 포함
- [ ] INSERT ... SELECT 패턴 사용, 루프 기반 INSERT 지양
- [ ] 인덱스 생성 타이밍 검토 (사후 생성 여부)
- [ ] 실행 결과 검증용 `COUNT(*)` / 샘플 조회 포함

---

## 7. 요약 결론

- 대규모 테스트 데이터 생성의 핵심
  - 단순하고 재현 가능한 스크립트
  - DB 엔진 제약을 피해 가는 설계
- MySQL 환경
  - 재귀 CTE보다 TEMP TABLE + 헬퍼 테이블 방식 우선
  - 애플리케이션 단일 row 삽입 대신 대량 INSERT ... SELECT 적극 활용
- 이 가이드를 기준으로 프로젝트별 요구사항에 맞게
  - 데이터 규모, 분포, 인덱스 구성을 조정하면 됨
